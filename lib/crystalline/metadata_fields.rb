# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: false
# frozen_string_literal: true

module Crystalline
  module MetadataFields

    class Field
      attr_accessor :name, :type, :metadata

      def initialize(name, type, metadata)
        @name = name
        @type = type
        @metadata = metadata
      end
    end

    module ClassMethods

      def fields
        @__fields__ = [] if @__fields__.nil?

        @__fields__
      end

      def field(field_name, type, metadata = {})
        attr_accessor field_name

        fields << Field.new(field_name, type, metadata)
      end

      def field_augmented?
        true
      end

      def unmarshal_single(field_type, value, format_metadata = nil)
        decoder = format_metadata.fetch(:decoder, nil)

        # Delegate complex Crystalline types to unmarshal_json
        if field_type.is_a?(Crystalline::DiscriminatedUnion) ||
           Crystalline::Utils.arr?(field_type) ||
           Crystalline::Utils.hash?(field_type) ||
           Crystalline::Utils.union?(field_type)
          return Crystalline.unmarshal_json(value, field_type)
        elsif field_type.instance_of?(Class) && field_type.include?(::Crystalline::MetadataFields)
          return field_type.from_dict(value)
        elsif field_type.to_s == 'Date'
          return Date.parse(value)
        elsif field_type.to_s == 'DateTime'
          return DateTime.parse(value)
        elsif field_type.to_s == 'Object'
          if value.is_a?(::String)
            trimmed = value.lstrip
            if trimmed.start_with?('{') || trimmed.start_with?('[')
              # rubocop:disable Lint/SuppressedException
              begin
                value = JSON.parse(value)
              rescue TypeError, JSON::ParserError
              end
              # rubocop:enable Lint/SuppressedException
            end
          end
          return value
        elsif field_type.to_s == 'Float'
          return value.to_f

        end
        if decoder.nil?
          value
        else
          decoder.call(value)
        end
      end

      def from_dict(d)
        to_build = {}

        # Collect lookup keys for regular fields so we can identify additional properties later
        known_keys = {}
        additional_props_fields = []
        fields.each do |field|
          format_metadata = field.metadata.fetch(:format_json, {})
          if format_metadata.fetch(:additional_properties, false)
            additional_props_fields << field
          else
            lookup = format_metadata.fetch(:letter_case, nil).call
            known_keys[lookup] = true
          end
        end

        # Process regular fields
        (fields - additional_props_fields).each do |field|
          key = field.name
          format_metadata = field.metadata.fetch(:format_json, {})
          field_type = field.type

          lookup = format_metadata.fetch(:letter_case, nil).call
          value = d[lookup]
          if ::Crystalline::Utils.nilable? field_type
            if value == 'null'
              to_build[key] = nil
              next
            end
            field_type = ::Crystalline::Utils.nilable_of(field_type)
          end

          # If field is not nilable, and the value is not in the dict, raise a KeyError
          raise KeyError, "key #{lookup} not found in hash" if value.nil? && !::Crystalline::Utils.nilable?(field.type)
          # If field is nilable, and the value is not in the dict, just move to the next field
          next if value.nil?

          if field_type.is_a?(Crystalline::DiscriminatedUnion)
            to_build[key] = field_type.parse(value)
          elsif Crystalline::Utils.arr? field_type
            inner_type = Crystalline::Utils.arr_of(field_type)
            unmarshalled_array = value.map { |f| unmarshal_single(inner_type, f, format_metadata) }
            to_build[key] = unmarshalled_array
          elsif Crystalline::Utils.hash? field_type
            val_type = Crystalline::Utils.hash_of(field_type)

            # rubocop:disable Style/HashTransformValues
            unmarshalled_hash = value.map { |k, v| [k, unmarshal_single(val_type, v, format_metadata)] }.to_h
            # rubocop:enable Style/HashTransformValues
            to_build[key] = unmarshalled_hash
          elsif Crystalline::Utils.union? field_type
            discriminator = field.metadata.fetch(:discriminator, nil)
            discriminator_mapping = field.metadata.fetch(:discriminator_mapping, nil)
            if !discriminator.nil?
              discriminator_value = value.fetch(discriminator)
              if !discriminator_mapping.nil?
                # Use explicit mapping from discriminator value to type
                type_to_deserialize = discriminator_mapping[discriminator_value]
              else
                # Fallback: try to match discriminator value against type name
                type_to_deserialize = Crystalline::Utils.get_union_types(field_type).find { |t| t.name.split('::').last == discriminator_value }
              end
              to_build[key] = Crystalline.unmarshal_json(value, type_to_deserialize)
            else
              union_types = Crystalline::Utils.get_union_types(field_type)
              union_types = union_types.sort_by { |klass| Crystalline.non_nilable_attr_count(klass) }

              if Crystalline.union_strategy == :populated_fields
                to_build[key] = Crystalline.unmarshal_union_populated_fields(value, union_types)
              else
                union_types.each do |union_type|
                  begin
                    to_build[key] = Crystalline.unmarshal_json(value, union_type)
                  rescue TypeError
                    next
                  rescue NoMethodError
                    next
                  rescue KeyError
                    next
                  end
                  break
                end
              end
            end
          elsif field_type.instance_of?(Class) && field_type.include?(::Crystalline::MetadataFields)
            to_build[key] = Crystalline.unmarshal_json(value, field_type)
          else
            to_build[key] = unmarshal_single(field_type, value, format_metadata)
          end
        end

        # Process additional properties fields: collect remaining keys from the dict
        additional_props_fields.each do |field|
          key = field.name
          format_metadata = field.metadata.fetch(:format_json, {})
          field_type = field.type

          remaining = d.reject { |k, _| known_keys.key?(k) }
          if remaining.empty?
            next if ::Crystalline::Utils.nilable?(field.type)

            raise KeyError, 'no additional properties found in hash'
          end

          inner_field_type = field_type
          inner_field_type = ::Crystalline::Utils.nilable_of(inner_field_type) if ::Crystalline::Utils.nilable?(inner_field_type)
          if Crystalline::Utils.hash?(inner_field_type)
            val_type = Crystalline::Utils.hash_of(inner_field_type)
            # rubocop:disable Style/HashTransformValues
            to_build[key] = remaining.map { |k, v| [k, unmarshal_single(val_type, v, format_metadata)] }.to_h
            # rubocop:enable Style/HashTransformValues
          else
            to_build[key] = remaining
          end
        end

        new(**to_build)
      end
    end

    def initialize
      instance = allocate
      fields.each { |mod| instance.singleton_class.include(mod) }
      instance.send(:initialize)
    end

    def self.included(base)
      base.extend(ClassMethods)
    end

    def fields
      self.class.fields
    end

    def field(field_name)
      fields.each do |f|
        return f if f.name == field_name
      end
    end

    def marshal_single(field)
      if field.class.include? ::Crystalline::MetadataFields
        field.to_dict
      else
        if ::Crystalline.needs_string_conversion field
          ::Crystalline.json_encode field
        else
          field
        end
      end
    end

    def to_dict
      result = {}
      fields.sort_by(&:name).each do |field|
        format_json_meta = field.metadata[:format_json]
        required = !format_json_meta.nil? && format_json_meta.include?(:required)
        is_additional_props = !format_json_meta.nil? && format_json_meta.fetch(:additional_properties, false)

        if !format_json_meta.nil? && format_json_meta.include?(:letter_case)
          key = format_json_meta[:letter_case].call(field.name)
        else
          key = field.name
        end

        f = send(field.name)
        next if f.nil? && !required
        result[key] = nil if f.nil? && required

        # Flatten additional properties into the parent object
        if is_additional_props && f.is_a?(::Hash)
          f.each { |k, v| result[k] = marshal_single(v) }
        elsif f.is_a? ::Array
          result[key] = f.map { |o| marshal_single(o) }
        elsif f.is_a? ::Hash
          result[key] = f.transform_values { |v| marshal_single(v) }
        else
          result[key] = marshal_single(f)
        end
      end
      result
    end

    def to_json(*args)
      JSON.generate(to_dict, *args)
    end
  end


end
