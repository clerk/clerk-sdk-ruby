# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: false
# frozen_string_literal: true

module Crystalline
  @union_strategy = :left_to_right

  class << self
    attr_accessor :union_strategy
  end

  def self.to_dict(complex)
    if complex.is_a? ::Array
      complex.map { |v| Crystalline.to_dict(v) }
    elsif complex.is_a? ::Hash
      complex.transform_values { |v| Crystalline.to_dict(v) }
    elsif complex.respond_to?(:class) && complex.class.include?(::Crystalline::MetadataFields)
      complex.to_dict
    else
      json_encode complex, primitives: false
    end
  end

  def self.needs_string_conversion(val)
    val.class.respond_to?(:enums) || val.is_a?(DateTime) || val.nil?
  end

  def self.to_json(complex)
    JSON.dump(to_dict(complex))
  end

  def self.unmarshal_json(data, type)
    if Crystalline::Utils.nilable? type
      type = Crystalline::Utils.nilable_of type
    end
    if type.is_a?(Crystalline::DiscriminatedUnion)
      type.parse(data)
    elsif type.instance_of?(Class) && type.include?(::Crystalline::MetadataFields)
      type.from_dict(data)
    elsif Crystalline::Utils.union? type
      union_types = Crystalline::Utils.get_union_types(type)
      union_types = union_types.sort_by { |klass| Crystalline.non_nilable_attr_count(klass) }

      if Crystalline.union_strategy == :populated_fields
        Crystalline.unmarshal_union_populated_fields(data, union_types)
      else
        Crystalline.unmarshal_union_left_to_right(data, union_types)
      end
    elsif Crystalline::Utils.arr? type
      data.map { |v| Crystalline.unmarshal_json(v, Crystalline::Utils.arr_of(type)) }
    elsif Crystalline::Utils.hash? type
      data.transform_values { |v| Crystalline.unmarshal_json(v, Crystalline::Utils.hash_of(type)) }
    elsif Crystalline::Utils.nilable?(type) && data == 'null'
      nil
    elsif Crystalline::Utils.boolean? type
      Crystalline::Utils.to_boolean(data)
    elsif type.is_a?(Class) && type.respond_to?(:enums) && type.respond_to?(:deserialize)
      type.deserialize(data)
    else
      data
    end
  end

  def self.json_encode(val, primitives: true)
    if val.class.respond_to? :enums
      val.serialize
    elsif val.is_a? DateTime
      val.strftime('%Y-%m-%dT%H:%M:%S.%NZ').sub(/(\.\d*[1-9])0+Z\z/, '\1Z').sub(/\.0+Z\z/, 'Z')
    elsif val.nil?
      nil
    elsif primitives
      val.to_s
    else
      val
    end
  end

  def self.unmarshal_union_left_to_right(data, union_types)
    union_types.each do |union_type|
      return Crystalline.unmarshal_json(data, union_type)
    rescue TypeError
      next
    rescue NoMethodError
      next
    rescue KeyError
      next
    end
    nil
  end

  def self.unmarshal_union_populated_fields(data, union_types)
    best_value = nil
    best_matched = -1
    best_inexact = 0
    best_unmatched = 0

    union_types.each do |union_type|
      value = Crystalline.unmarshal_json(data, union_type)
      matched, inexact, unmatched = count_matched_fields(value, data)

      if best_value.nil? ||
         matched > best_matched ||
         (matched == best_matched && inexact < best_inexact) ||
         (matched == best_matched && inexact == best_inexact && unmatched < best_unmatched)
        best_value = value
        best_matched = matched
        best_inexact = inexact
        best_unmatched = unmatched
      end
    rescue TypeError
      next
    rescue NoMethodError
      next
    rescue KeyError
      next
    end
    best_value
  end

  def self.count_matched_fields(value, raw_data)
    matched = 0
    inexact = 0
    unmatched = 0

    if value.is_a?(Crystalline::Unknown)
      return [0, 0, 0]
    elsif value.class.include?(::Crystalline::MetadataFields)
      value.fields.each do |field|
        format_metadata = field.metadata.fetch(:format_json, {})
        lookup = format_metadata.fetch(:letter_case, nil)&.call
        field_val = value.send(field.name)

        if raw_data.is_a?(::Hash) && lookup && raw_data.key?(lookup)
          if field_val.class.include?(::Crystalline::MetadataFields) && raw_data[lookup].is_a?(::Hash)
            nested_matched, nested_inexact, nested_unmatched = count_matched_fields(field_val, raw_data[lookup])
            matched += nested_matched
            inexact += nested_inexact
            unmatched += nested_unmatched
          else
            matched += 1
            if field_val.respond_to?(:known?) && !field_val.known?
              inexact += 1
            end
          end
        elsif !::Crystalline::Utils.nilable?(field.type)
          unmatched += 1
        end
      end
    elsif value.is_a?(::Array)
      matched = value.length
    elsif value.is_a?(::Hash)
      matched = value.length
    else
      matched = 1
    end

    [matched, inexact, unmatched]
  end

  def self.non_nilable_attr_count(klass)
    # somewhat sane sort ordering for Union deserialization.
    # All Crystalline objects return the number of non-nilable fields
    # All non-string primitives return 2
    # All arrays and hashes return 1
    # Strings return 0 (since any data can deserialize to a string, it should be our last attempt)
    if klass.respond_to? :fields
      return -1 * klass.fields.count do |field|
        !::Crystalline::Utils.nilable? field.type
      end
    else
      if klass == String
        return 0
      end
      return 2
    end
  end
end
