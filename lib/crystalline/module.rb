# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: false
# frozen_string_literal: true

module Crystalline

  def self.to_dict(complex)
    if complex.is_a? Array
      complex.map { |v| Crystalline.to_dict(v) }
    elsif complex.is_a? Hash
      complex.transform_values { |v| Crystalline.to_dict(v) }
    elsif complex.respond_to?(:class) && complex.class.include?(::Crystalline::MetadataFields)
      complex.to_dict
    else
      json_encode complex, primitives: false
    end
  end

  def self.needs_string_conversion(val)
    val.class.respond_to?(:enums) || val.is_a?(DateTime) || val.nil?
  end

  def self.to_json(complex)
    JSON.dump(to_dict(complex))
  end

  def self.unmarshal_json(data, type)
    if Crystalline::Utils.nilable? type
      type = Crystalline::Utils.nilable_of type
    end
    if type.instance_of?(Class) && type.include?(::Crystalline::MetadataFields)
      type.from_dict(data)
    elsif Crystalline::Utils.union? type
      union_types = Crystalline::Utils.get_union_types(type)
      union_types = union_types.sort_by { |klass| Crystalline.non_nilable_attr_count(klass) }

      union_types.each do |union_type|
        unmarshalled_val = Crystalline.unmarshal_json(data, union_type)
        return unmarshalled_val
      rescue TypeError
        next
      rescue NoMethodError
        next
      rescue KeyError
        next
      end
    elsif Crystalline::Utils.arr? type
      data.map { |v| Crystalline.unmarshal_json(v, Crystalline::Utils.arr_of(type)) }
    elsif Crystalline::Utils.hash? type
      data.transform_values { |v| Crystalline.unmarshal_json(v, Crystalline::Utils.hash_of(type)) }
    elsif Crystalline::Utils.nilable?(type) && data == 'null'
      nil
    elsif Crystalline::Utils.boolean? type
      Crystalline::Utils.to_boolean(data)
    elsif type.is_a?(Class) && type < T::Enum
      type.deserialize(data)
    else
      data
    end
  end

  def self.json_encode(val, primitives: true)
    if val.class.respond_to? :enums
      val.serialize
    elsif val.is_a? DateTime
      val.strftime('%Y-%m-%dT%H:%M:%S.%NZ')
    elsif val.nil?
      nil
    elsif primitives
      val.to_s
    else
      val
    end
  end

  def self.non_nilable_attr_count(klass)
    # somewhat sane sort ordering for Union deserialization.
    # All Crystalline objects return the number of non-nilable fields
    # All non-string primitives return 2
    # All arrays and hashes return 1
    # Strings return 0 (since any data can deserialize to a string, it should be our last attempt)
    if klass.respond_to? :fields
      return -1 * klass.fields.count do |field|
        !::Crystalline::Utils.nilable? field.type
      end
    else
      if klass == String
        return 0
      elsif klass.is_a?(T::Types::TypedArray) || klass.is_a?(T::Types::TypedHash)
        return 1
      end
      return 2
    end
  end
end
