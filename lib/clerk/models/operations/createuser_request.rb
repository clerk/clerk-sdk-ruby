# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: false
# frozen_string_literal: true


module Clerk
  module Models
    module Operations

      class CreateUserRequest
        
        include Crystalline::MetadataFields

        # Email addresses to add to the user.
        # Must be unique across your instance.
        # The first email address will be set as the user's primary email address.
        field :email_address, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('email_address') } }
        # Phone numbers to add to the user.
        # Must be unique across your instance.
        # The first phone number will be set as the user's primary phone number.
        field :phone_number, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('phone_number') } }
        # Web3 wallets to add to the user.
        # Must be unique across your instance.
        # The first wallet will be set as the user's primary wallet.
        field :web3_wallet, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('web3_wallet') } }
        # The hashing algorithm that was used to generate the password digest.
        #
        # The algorithms we support at the moment are [`bcrypt`](https://en.wikipedia.org/wiki/Bcrypt), [`bcrypt_sha256_django`](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/), [`md5`](https://en.wikipedia.org/wiki/MD5), `pbkdf2_sha1`, `pbkdf2_sha256`, [`pbkdf2_sha256_django`](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/),
        # [`phpass`](https://www.openwall.com/phpass/), `md5_phpass`, [`scrypt_firebase`](https://firebaseopensource.com/projects/firebase/scrypt/),
        # [`scrypt_werkzeug`](https://werkzeug.palletsprojects.com/en/3.0.x/utils/#werkzeug.security.generate_password_hash), [`sha256`](https://en.wikipedia.org/wiki/SHA-2),
        # [`ldap_ssha`](https://www.openldap.org/faq/data/cache/347.html), the [`argon2`](https://argon2.online/) variants: `argon2i` and `argon2id`, and `sha512_symfony`, the SHA-512 variant of the [Symfony](https://symfony.com/doc/current/security/passwords.html) legacy hasher.
        #
        # Each of the supported hashers expects the incoming digest to be in a particular format. See the [Clerk docs](https://clerk.com/docs/references/backend/user/create-user) for more information.
        field :password_hasher, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('password_hasher') } }
        # If Backup Codes are configured on the instance, you can provide them to enable it on the newly created user without the need to reset them.
        # You must provide the backup codes in plain format or the corresponding bcrypt digest.
        field :backup_codes, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('backup_codes') } }
        # Metadata saved on the user, that is visible to both your Frontend and Backend APIs
        field :public_metadata, Crystalline::Nilable.new(Crystalline::Hash.new(Symbol, ::Object)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('public_metadata') } }
        # Metadata saved on the user, that is only visible to your Backend API
        field :private_metadata, Crystalline::Nilable.new(Crystalline::Hash.new(Symbol, ::Object)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('private_metadata') } }
        # Metadata saved on the user, that can be updated from both the Frontend and Backend APIs.
        # Note: Since this data can be modified from the frontend, it is not guaranteed to be safe.
        field :unsafe_metadata, Crystalline::Nilable.new(Crystalline::Hash.new(Symbol, ::Object)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('unsafe_metadata') } }
        # The ID of the user as used in your external systems or your previous authentication solution.
        # Must be unique across your instance.
        field :external_id, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('external_id') } }
        # The first name to assign to the user
        field :first_name, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('first_name') } }
        # The last name to assign to the user
        field :last_name, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('last_name') } }
        # The locale to assign to the user (e.g., "en-US", "fr-FR")
        field :locale, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('locale') } }
        # The username to give to the user.
        # It must be unique across your instance.
        field :username, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('username') } }
        # The plaintext password to give the user.
        # Must be at least 8 characters long, and cannot be in any list of hacked passwords.
        field :password, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('password') } }
        # In case you already have the password digests and not the passwords, you can use them for the newly created user via this property.
        # The digests should be generated with one of the supported algorithms.
        # The hashing algorithm can be specified using the `password_hasher` property.
        field :password_digest, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('password_digest') } }
        # When set to `true` all password checks are skipped.
        # It is recommended to use this method only when migrating plaintext passwords to Clerk.
        # Upon migration the user base should be prompted to pick stronger password.
        field :skip_password_checks, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('skip_password_checks') } }
        # When set to `true`, `password` is not required anymore when creating the user and can be omitted.
        # This is useful when you are trying to create a user that doesn't have a password, in an instance that is using passwords.
        # Please note that you cannot use this flag if password is the only way for a user to sign into your instance.
        field :skip_password_requirement, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('skip_password_requirement') } }
        # In case TOTP is configured on the instance, you can provide the secret to enable it on the newly created user without the need to reset it.
        # Please note that currently the supported options are:
        # * Period: 30 seconds
        # * Code length: 6 digits
        # * Algorithm: SHA1
        field :totp_secret, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('totp_secret') } }
        # If enabled, user can delete themselves via FAPI.
        #
        field :delete_self_enabled, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('delete_self_enabled') } }
        # A custom timestamp denoting _when_ the user accepted legal requirements, specified in RFC3339 format (e.g. `2012-10-20T07:15:20.902Z`).
        field :legal_accepted_at, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('legal_accepted_at') } }
        # When set to `true` all legal checks are skipped.
        # It is not recommended to skip legal checks unless you are migrating a user to Clerk.
        field :skip_legal_checks, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('skip_legal_checks') } }
        # When set to `true`, identification types are not enforced.
        # At least one identification type must be enabled and provided on your instance (email, phone, web3 wallet, or username).
        # Users created without required identification types cannot use those authentication strategies
        # It is not recommended to use this flag unless you need to allow Clerk UI components to prompt for required fields while BAPI creates users with minimal data, or for migration a user to Clerk.
        field :skip_user_requirement, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('skip_user_requirement') } }
        # If enabled, user can create organizations via FAPI.
        #
        field :create_organization_enabled, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('create_organization_enabled') } }
        # The maximum number of organizations the user can create. 0 means unlimited.
        #
        field :create_organizations_limit, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('create_organizations_limit') } }
        # A custom date/time denoting _when_ the user signed up to the application, specified in RFC3339 format (e.g. `2012-10-20T07:15:20.902Z`).
        field :created_at, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('created_at') } }
        # When set to `true`, the user will bypass client trust checks during sign-in.
        field :bypass_client_trust, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('bypass_client_trust') } }

        
        def initialize(email_address: nil, phone_number: nil, web3_wallet: nil, password_hasher: nil, backup_codes: nil, public_metadata: nil, private_metadata: nil, unsafe_metadata: nil, external_id: nil, first_name: nil, last_name: nil, locale: nil, username: nil, password: nil, password_digest: nil, skip_password_checks: nil, skip_password_requirement: nil, totp_secret: nil, delete_self_enabled: nil, legal_accepted_at: nil, skip_legal_checks: nil, skip_user_requirement: nil, create_organization_enabled: nil, create_organizations_limit: nil, created_at: nil, bypass_client_trust: nil)
          @email_address = email_address
          @phone_number = phone_number
          @web3_wallet = web3_wallet
          @password_hasher = password_hasher
          @backup_codes = backup_codes
          @public_metadata = public_metadata
          @private_metadata = private_metadata
          @unsafe_metadata = unsafe_metadata
          @external_id = external_id
          @first_name = first_name
          @last_name = last_name
          @locale = locale
          @username = username
          @password = password
          @password_digest = password_digest
          @skip_password_checks = skip_password_checks
          @skip_password_requirement = skip_password_requirement
          @totp_secret = totp_secret
          @delete_self_enabled = delete_self_enabled
          @legal_accepted_at = legal_accepted_at
          @skip_legal_checks = skip_legal_checks
          @skip_user_requirement = skip_user_requirement
          @create_organization_enabled = create_organization_enabled
          @create_organizations_limit = create_organizations_limit
          @created_at = created_at
          @bypass_client_trust = bypass_client_trust
        end

        
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @email_address == other.email_address
          return false unless @phone_number == other.phone_number
          return false unless @web3_wallet == other.web3_wallet
          return false unless @password_hasher == other.password_hasher
          return false unless @backup_codes == other.backup_codes
          return false unless @public_metadata == other.public_metadata
          return false unless @private_metadata == other.private_metadata
          return false unless @unsafe_metadata == other.unsafe_metadata
          return false unless @external_id == other.external_id
          return false unless @first_name == other.first_name
          return false unless @last_name == other.last_name
          return false unless @locale == other.locale
          return false unless @username == other.username
          return false unless @password == other.password
          return false unless @password_digest == other.password_digest
          return false unless @skip_password_checks == other.skip_password_checks
          return false unless @skip_password_requirement == other.skip_password_requirement
          return false unless @totp_secret == other.totp_secret
          return false unless @delete_self_enabled == other.delete_self_enabled
          return false unless @legal_accepted_at == other.legal_accepted_at
          return false unless @skip_legal_checks == other.skip_legal_checks
          return false unless @skip_user_requirement == other.skip_user_requirement
          return false unless @create_organization_enabled == other.create_organization_enabled
          return false unless @create_organizations_limit == other.create_organizations_limit
          return false unless @created_at == other.created_at
          return false unless @bypass_client_trust == other.bypass_client_trust
          true
        end
      end
    end
  end
end
