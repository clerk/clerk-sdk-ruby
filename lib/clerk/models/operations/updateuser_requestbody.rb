# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: false
# frozen_string_literal: true


module Clerk
  module Models
    module Operations

      class UpdateUserRequestBody
        
        include Crystalline::MetadataFields

        # In case you already have the password digests and not the passwords, you can use them for the newly created user via this property.
        # The digests should be generated with one of the supported algorithms.
        # The hashing algorithm can be specified using the `password_hasher` property.
        field :password_digest, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('password_digest') } }
        # The hashing algorithm that was used to generate the password digest.
        #
        # The algorithms we support at the moment are [`bcrypt`](https://en.wikipedia.org/wiki/Bcrypt), [`bcrypt_sha256_django`](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/), [`md5`](https://en.wikipedia.org/wiki/MD5), `pbkdf2_sha1`, `pbkdf2_sha256`, [`pbkdf2_sha256_django`](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/),
        # [`phpass`](https://www.openwall.com/phpass/), `md5_phpass`, [`scrypt_firebase`](https://firebaseopensource.com/projects/firebase/scrypt/),
        # [`scrypt_werkzeug`](https://werkzeug.palletsprojects.com/en/3.0.x/utils/#werkzeug.security.generate_password_hash), [`sha256`](https://en.wikipedia.org/wiki/SHA-2),
        # [`ldap_ssha`](https://www.openldap.org/faq/data/cache/347.html), the [`argon2`](https://argon2.online/) variants: `argon2i` and `argon2id`, and `sha512_symfony`, the SHA-512 variant of the [Symfony](https://symfony.com/doc/current/security/passwords.html) legacy hasher.
        #
        # Each of the supported hashers expects the incoming digest to be in a particular format. See the [Clerk docs](https://clerk.com/docs/references/backend/user/create-user) for more information.
        field :password_hasher, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('password_hasher') } }
        # If Backup Codes are configured on the instance, you can provide them to enable it on the specific user without the need to reset them.
        # You must provide the backup codes in plain format or the corresponding bcrypt digest.
        field :backup_codes, Crystalline::Nilable.new(Crystalline::Array.new(::String)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('backup_codes') } }
        # The ID of the user as used in your external systems or your previous authentication solution.
        # Must be unique across your instance.
        field :external_id, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('external_id') } }
        # The first name to assign to the user
        field :first_name, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('first_name') } }
        # The last name to assign to the user
        field :last_name, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('last_name') } }
        # The locale to assign to the user (e.g., "en-US", "fr-FR")
        field :locale, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('locale') } }
        # The ID of the email address to set as primary.
        # It must be verified, and present on the current user.
        field :primary_email_address_id, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('primary_email_address_id') } }
        # The ID of the phone number to set as primary.
        # It must be verified, and present on the current user.
        field :primary_phone_number_id, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('primary_phone_number_id') } }
        # The ID of the web3 wallets to set as primary.
        # It must be verified, and present on the current user.
        field :primary_web3_wallet_id, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('primary_web3_wallet_id') } }
        # The username to give to the user.
        # It must be unique across your instance.
        field :username, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('username') } }
        # The ID of the image to set as the user's profile image
        field :profile_image_id, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('profile_image_id') } }
        # The plaintext password to give the user.
        # Must be at least 8 characters long, and cannot be in any list of hacked passwords.
        field :password, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('password') } }
        # Set it to `true` if you're updating the user's password and want to skip any password policy settings check. This parameter can only be used when providing a `password`.
        field :skip_password_checks, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('skip_password_checks') } }
        # Set to `true` to sign out the user from all their active sessions once their password is updated. This parameter can only be used when providing a `password`.
        field :sign_out_of_other_sessions, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('sign_out_of_other_sessions') } }
        # In case TOTP is configured on the instance, you can provide the secret to enable it on the specific user without the need to reset it.
        # Please note that currently the supported options are:
        # * Period: 30 seconds
        # * Code length: 6 digits
        # * Algorithm: SHA1
        field :totp_secret, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('totp_secret') } }
        # Metadata saved on the user, that is visible to both your Frontend and Backend APIs
        field :public_metadata, Crystalline::Nilable.new(Crystalline::Hash.new(Symbol, ::Object)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('public_metadata') } }
        # Metadata saved on the user, that is only visible to your Backend API
        field :private_metadata, Crystalline::Nilable.new(Crystalline::Hash.new(Symbol, ::Object)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('private_metadata') } }
        # Metadata saved on the user, that can be updated from both the Frontend and Backend APIs.
        # Note: Since this data can be modified from the frontend, it is not guaranteed to be safe.
        field :unsafe_metadata, Crystalline::Nilable.new(Crystalline::Hash.new(Symbol, ::Object)), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('unsafe_metadata') } }
        # If true, the user can delete themselves with the Frontend API.
        field :delete_self_enabled, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('delete_self_enabled') } }
        # If true, the user can create organizations with the Frontend API.
        field :create_organization_enabled, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('create_organization_enabled') } }
        # A custom timestamp denoting _when_ the user accepted legal requirements, specified in RFC3339 format (e.g. `2012-10-20T07:15:20.902Z`).
        field :legal_accepted_at, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('legal_accepted_at') } }
        # When set to `true` all legal checks are skipped.
        # It is not recommended to skip legal checks unless you are migrating a user to Clerk.
        field :skip_legal_checks, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('skip_legal_checks') } }
        # The maximum number of organizations the user can create. 0 means unlimited.
        field :create_organizations_limit, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('create_organizations_limit') } }
        # A custom date/time denoting _when_ the user signed up to the application, specified in RFC3339 format (e.g. `2012-10-20T07:15:20.902Z`).
        field :created_at, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('created_at') } }
        # When set to `true`, the user will bypass client trust checks during sign-in.
        field :bypass_client_trust, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('bypass_client_trust') } }
        # If set to `true`, the user will be notified that their primary email address has changed.
        # By default, no notification is sent.
        field :notify_primary_email_address_changed, Crystalline::Nilable.new(Crystalline::Boolean.new), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('notify_primary_email_address_changed') } }

        
        def initialize(password_digest: nil, password_hasher: nil, backup_codes: nil, external_id: nil, first_name: nil, last_name: nil, locale: nil, primary_email_address_id: nil, primary_phone_number_id: nil, primary_web3_wallet_id: nil, username: nil, profile_image_id: nil, password: nil, skip_password_checks: nil, sign_out_of_other_sessions: nil, totp_secret: nil, public_metadata: nil, private_metadata: nil, unsafe_metadata: nil, delete_self_enabled: nil, create_organization_enabled: nil, legal_accepted_at: nil, skip_legal_checks: nil, create_organizations_limit: nil, created_at: nil, bypass_client_trust: nil, notify_primary_email_address_changed: false)
          @password_digest = password_digest
          @password_hasher = password_hasher
          @backup_codes = backup_codes
          @external_id = external_id
          @first_name = first_name
          @last_name = last_name
          @locale = locale
          @primary_email_address_id = primary_email_address_id
          @primary_phone_number_id = primary_phone_number_id
          @primary_web3_wallet_id = primary_web3_wallet_id
          @username = username
          @profile_image_id = profile_image_id
          @password = password
          @skip_password_checks = skip_password_checks
          @sign_out_of_other_sessions = sign_out_of_other_sessions
          @totp_secret = totp_secret
          @public_metadata = public_metadata
          @private_metadata = private_metadata
          @unsafe_metadata = unsafe_metadata
          @delete_self_enabled = delete_self_enabled
          @create_organization_enabled = create_organization_enabled
          @legal_accepted_at = legal_accepted_at
          @skip_legal_checks = skip_legal_checks
          @create_organizations_limit = create_organizations_limit
          @created_at = created_at
          @bypass_client_trust = bypass_client_trust
          @notify_primary_email_address_changed = notify_primary_email_address_changed
        end

        
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @password_digest == other.password_digest
          return false unless @password_hasher == other.password_hasher
          return false unless @backup_codes == other.backup_codes
          return false unless @external_id == other.external_id
          return false unless @first_name == other.first_name
          return false unless @last_name == other.last_name
          return false unless @locale == other.locale
          return false unless @primary_email_address_id == other.primary_email_address_id
          return false unless @primary_phone_number_id == other.primary_phone_number_id
          return false unless @primary_web3_wallet_id == other.primary_web3_wallet_id
          return false unless @username == other.username
          return false unless @profile_image_id == other.profile_image_id
          return false unless @password == other.password
          return false unless @skip_password_checks == other.skip_password_checks
          return false unless @sign_out_of_other_sessions == other.sign_out_of_other_sessions
          return false unless @totp_secret == other.totp_secret
          return false unless @public_metadata == other.public_metadata
          return false unless @private_metadata == other.private_metadata
          return false unless @unsafe_metadata == other.unsafe_metadata
          return false unless @delete_self_enabled == other.delete_self_enabled
          return false unless @create_organization_enabled == other.create_organization_enabled
          return false unless @legal_accepted_at == other.legal_accepted_at
          return false unless @skip_legal_checks == other.skip_legal_checks
          return false unless @create_organizations_limit == other.create_organizations_limit
          return false unless @created_at == other.created_at
          return false unless @bypass_client_trust == other.bypass_client_trust
          return false unless @notify_primary_email_address_changed == other.notify_primary_email_address_changed
          true
        end
      end
    end
  end
end
