# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: false
# frozen_string_literal: true


module Clerk
  module Models
    module Components
      # A commerce subscription item.
      class SchemasCommerceSubscriptionItem
        
        include Crystalline::MetadataFields

        # String representing the object's type. Objects of the same type share the same value.
        field :object, Models::Components::SchemasCommerceSubscriptionItemObjectCommerceSubscriptionItem, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('object'), required: true, 'decoder': ::Clerk::Utils.enum_from_string(Models::Components::SchemasCommerceSubscriptionItemObjectCommerceSubscriptionItem, false) } }
        # Unique identifier for the subscription item.
        field :id, ::String, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('id'), required: true } }
        # Unique identifier for the Clerk instance.
        field :instance_id, ::String, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('instance_id'), required: true } }
        # Current status of the subscription item.
        field :status, Models::Components::SchemasCommerceSubscriptionItemStatus, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('status'), required: true, 'decoder': ::Clerk::Utils.enum_from_string(Models::Components::SchemasCommerceSubscriptionItemStatus, false) } }
        # Unique identifier for the associated plan.
        field :plan_id, ::String, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('plan_id'), required: true } }
        # The billing period for this subscription.
        field :plan_period, Models::Components::SchemasCommerceSubscriptionItemPlanPeriod, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('plan_period'), required: true, 'decoder': ::Clerk::Utils.enum_from_string(Models::Components::SchemasCommerceSubscriptionItemPlanPeriod, false) } }
        # Unique identifier for the payment source.
        field :payment_source_id, ::String, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('payment_source_id'), required: true } }
        # Unique identifier for the payer.
        field :payer_id, ::String, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('payer_id'), required: true } }
        # Whether this subscription is currently on a free trial.
        field :is_free_trial, Crystalline::Boolean.new, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('is_free_trial'), required: true } }
        # Date used for proration calculations.
        field :proration_date, ::String, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('proration_date'), required: true } }
        # Unix timestamp (in milliseconds) when the subscription was created.
        field :created_at, ::Integer, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('created_at'), required: true } }
        # Unix timestamp (in milliseconds) when the subscription was last updated.
        field :updated_at, ::Integer, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('updated_at'), required: true } }
        # Unique identifier for the associated price
        field :price_id, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('price_id') } }
        # The associated commerce plan.
        field :plan, Crystalline::Nilable.new(Models::Components::SchemasCommerceSubscriptionItemPlan), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('plan'), required: true } }
        # Credit information (only available in PaymentAttempt events).
        field :credit, Crystalline::Nilable.new(Models::Components::Credit), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('credit') } }
        # The payment source associated with this subscription.
        field :payment_source, Crystalline::Nilable.new(Models::Components::PaymentSource), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('payment_source') } }
        # Total amount paid over the lifetime of this subscription.
        field :lifetime_paid, Crystalline::Nilable.new(Models::Components::LifetimePaid), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('lifetime_paid') } }
        # Current amount for this subscription.
        field :amount, Crystalline::Nilable.new(Models::Components::SchemasCommerceSubscriptionItemAmount), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('amount') } }
        # Information about the next invoice.
        field :next_invoice, Crystalline::Nilable.new(Models::Components::NextInvoice), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('next_invoice') } }
        # Information about the next payment.
        field :next_payment, Crystalline::Nilable.new(Models::Components::SchemasCommerceSubscriptionItemNextPayment), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('next_payment') } }
        # The payer associated with this subscription.
        field :payer, Crystalline::Nilable.new(Models::Components::Payer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('payer') } }
        # Unix timestamp (in milliseconds) when the current period started.
        field :period_start, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('period_start') } }
        # Unix timestamp (in milliseconds) when the current period ends.
        field :period_end, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('period_end') } }
        # Unix timestamp (in milliseconds) when the subscription was canceled.
        field :canceled_at, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('canceled_at') } }
        # Unix timestamp (in milliseconds) when the subscription became past due.
        field :past_due_at, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('past_due_at') } }
        # Unix timestamp (in milliseconds) when the subscription ended.
        field :ended_at, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('ended_at') } }

        
        def initialize(object:, id:, instance_id:, status:, plan_id:, plan_period:, payment_source_id:, payer_id:, is_free_trial:, proration_date:, created_at:, updated_at:, price_id: nil, plan: nil, credit: nil, payment_source: nil, lifetime_paid: nil, amount: nil, next_invoice: nil, next_payment: nil, payer: nil, period_start: nil, period_end: nil, canceled_at: nil, past_due_at: nil, ended_at: nil)
          @object = object
          @id = id
          @instance_id = instance_id
          @status = status
          @plan_id = plan_id
          @plan_period = plan_period
          @payment_source_id = payment_source_id
          @payer_id = payer_id
          @is_free_trial = is_free_trial
          @proration_date = proration_date
          @created_at = created_at
          @updated_at = updated_at
          @price_id = price_id
          @plan = plan
          @credit = credit
          @payment_source = payment_source
          @lifetime_paid = lifetime_paid
          @amount = amount
          @next_invoice = next_invoice
          @next_payment = next_payment
          @payer = payer
          @period_start = period_start
          @period_end = period_end
          @canceled_at = canceled_at
          @past_due_at = past_due_at
          @ended_at = ended_at
        end

        
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @object == other.object
          return false unless @id == other.id
          return false unless @instance_id == other.instance_id
          return false unless @status == other.status
          return false unless @plan_id == other.plan_id
          return false unless @plan_period == other.plan_period
          return false unless @payment_source_id == other.payment_source_id
          return false unless @payer_id == other.payer_id
          return false unless @is_free_trial == other.is_free_trial
          return false unless @proration_date == other.proration_date
          return false unless @created_at == other.created_at
          return false unless @updated_at == other.updated_at
          return false unless @price_id == other.price_id
          return false unless @plan == other.plan
          return false unless @credit == other.credit
          return false unless @payment_source == other.payment_source
          return false unless @lifetime_paid == other.lifetime_paid
          return false unless @amount == other.amount
          return false unless @next_invoice == other.next_invoice
          return false unless @next_payment == other.next_payment
          return false unless @payer == other.payer
          return false unless @period_start == other.period_start
          return false unless @period_end == other.period_end
          return false unless @canceled_at == other.canceled_at
          return false unless @past_due_at == other.past_due_at
          return false unless @ended_at == other.ended_at
          true
        end
      end
    end
  end
end
