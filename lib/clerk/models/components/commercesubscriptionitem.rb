# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: false
# frozen_string_literal: true


module Clerk
  module Models
    module Components

      class CommerceSubscriptionItem
        
        include Crystalline::MetadataFields

        # String representing the object's type. Objects of the same type share the same value.
        field :object, Models::Components::CommerceSubscriptionItemObject, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('object'), required: true, 'decoder': ::Clerk::Utils.enum_from_string(Models::Components::CommerceSubscriptionItemObject, false) } }
        # Unique identifier for the subscription item.
        field :id, ::String, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('id'), required: true } }
        # Unique identifier for the Clerk instance.
        field :instance_id, ::String, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('instance_id'), required: true } }
        # Current status of the subscription item.
        field :status, Models::Components::CommerceSubscriptionItemStatus, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('status'), required: true, 'decoder': ::Clerk::Utils.enum_from_string(Models::Components::CommerceSubscriptionItemStatus, false) } }
        # The billing period for this subscription item.
        field :plan_period, Models::Components::CommerceSubscriptionItemPlanPeriod, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('plan_period'), required: true, 'decoder': ::Clerk::Utils.enum_from_string(Models::Components::CommerceSubscriptionItemPlanPeriod, false) } }
        # Unique identifier for the payer.
        field :payer_id, ::String, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('payer_id'), required: true } }
        # Whether this subscription item includes a free trial.
        field :is_free_trial, Crystalline::Boolean.new, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('is_free_trial'), required: true } }
        # Unix timestamp (in milliseconds) when the current period started.
        field :period_start, ::Integer, { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('period_start'), required: true } }

        field :credit, Crystalline::Nilable.new(Models::Components::CommerceSubscriptionCreditResponse), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('credit') } }
        # Unique identifier for the associated plan.
        field :plan_id, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('plan_id'), required: true } }
        # Unique identifier for the associated price
        field :price_id, Crystalline::Nilable.new(::String), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('price_id') } }

        field :payment_method, Crystalline::Nilable.new(Models::Components::CommercePaymentMethodResponse), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('payment_method') } }

        field :lifetime_paid, Crystalline::Nilable.new(Models::Components::CommerceMoneyResponse), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('lifetime_paid') } }

        field :payer, Crystalline::Nilable.new(Models::Components::CommercePayerResponse), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('payer') } }
        # Unix timestamp (in milliseconds) when the current period ends.
        field :period_end, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('period_end'), required: true } }
        # The day the subscription item was prorated from. Only available in some responses.
        field :proration_date, Crystalline::Nilable.new(::Date), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('proration_date'), 'decoder': ::Clerk::Utils.date_from_iso_format(true) } }
        # Unix timestamp (in milliseconds) when the subscription item was canceled.
        field :canceled_at, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('canceled_at'), required: true } }
        # Unix timestamp (in milliseconds) when the subscription item became past due.
        field :past_due_at, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('past_due_at'), required: true } }
        # Unix timestamp (in milliseconds) when the subscription item ended.
        field :ended_at, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('ended_at'), required: true } }
        # Unix timestamp (in milliseconds) when the subscription item was created.
        field :created_at, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('created_at') } }
        # Unix timestamp (in milliseconds) when the subscription item was last updated.
        field :updated_at, Crystalline::Nilable.new(::Integer), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('updated_at') } }
        # The associated plan.
        field :plan, Crystalline::Nilable.new(Models::Components::CommerceSubscriptionItemPlan), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('plan') } }
        # Information about the next payment.
        field :next_payment, Crystalline::Nilable.new(Models::Components::CommerceSubscriptionItemNextPayment), { 'format_json': { 'letter_case': ::Clerk::Utils.field_name('next_payment') } }

        
        def initialize(object:, id:, instance_id:, status:, plan_period:, payer_id:, is_free_trial:, period_start:, credit: nil, plan_id: nil, price_id: nil, payment_method: nil, lifetime_paid: nil, payer: nil, period_end: nil, proration_date: nil, canceled_at: nil, past_due_at: nil, ended_at: nil, created_at: nil, updated_at: nil, plan: nil, next_payment: nil)
          @object = object
          @id = id
          @instance_id = instance_id
          @status = status
          @plan_period = plan_period
          @payer_id = payer_id
          @is_free_trial = is_free_trial
          @period_start = period_start
          @credit = credit
          @plan_id = plan_id
          @price_id = price_id
          @payment_method = payment_method
          @lifetime_paid = lifetime_paid
          @payer = payer
          @period_end = period_end
          @proration_date = proration_date
          @canceled_at = canceled_at
          @past_due_at = past_due_at
          @ended_at = ended_at
          @created_at = created_at
          @updated_at = updated_at
          @plan = plan
          @next_payment = next_payment
        end

        
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @object == other.object
          return false unless @id == other.id
          return false unless @instance_id == other.instance_id
          return false unless @status == other.status
          return false unless @plan_period == other.plan_period
          return false unless @payer_id == other.payer_id
          return false unless @is_free_trial == other.is_free_trial
          return false unless @period_start == other.period_start
          return false unless @credit == other.credit
          return false unless @plan_id == other.plan_id
          return false unless @price_id == other.price_id
          return false unless @payment_method == other.payment_method
          return false unless @lifetime_paid == other.lifetime_paid
          return false unless @payer == other.payer
          return false unless @period_end == other.period_end
          return false unless @proration_date == other.proration_date
          return false unless @canceled_at == other.canceled_at
          return false unless @past_due_at == other.past_due_at
          return false unless @ended_at == other.ended_at
          return false unless @created_at == other.created_at
          return false unless @updated_at == other.updated_at
          return false unless @plan == other.plan
          return false unless @next_payment == other.next_payment
          true
        end
      end
    end
  end
end
