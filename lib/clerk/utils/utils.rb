# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: false
# frozen_string_literal: true

require 'cgi'
require 'date'
require 'base64'
require 'stringio'


module Clerk
  module Utils
    include Kernel
    

    
    def self.val_to_string(val)
      if val.class.respond_to?(:enums)
        val.serialize.to_s
      elsif val.is_a? DateTime
        val.strftime('%Y-%m-%dT%H:%M:%S.%NZ').sub(/(\.\d*[1-9])0+Z\z/, '\1Z').sub(/\.0+Z\z/, 'Z')
      else
        val.to_s

      end
    end

    MIME_TYPES = {
      '.json' => 'application/json',
      '.xml' => 'application/xml',
      '.pdf' => 'application/pdf',
      '.zip' => 'application/zip',
      '.gz' => 'application/gzip',
      '.csv' => 'text/csv',
      '.txt' => 'text/plain',
      '.html' => 'text/html',
      '.htm' => 'text/html',
      '.css' => 'text/css',
      '.js' => 'application/javascript',
      '.png' => 'image/png',
      '.jpg' => 'image/jpeg',
      '.jpeg' => 'image/jpeg',
      '.gif' => 'image/gif',
      '.svg' => 'image/svg+xml',
      '.webp' => 'image/webp',
      '.mp3' => 'audio/mpeg',
      '.mp4' => 'video/mp4',
      '.yaml' => 'application/yaml',
      '.yml' => 'application/yaml',
    }.freeze

    
    def self.mime_type_for_filename(filename)
      ext = File.extname(filename).downcase
      MIME_TYPES.fetch(ext, 'application/octet-stream')
    end

    
    def self._get_serialized_params(metadata, field_name, obj)
      params = {}

      serialization = metadata.fetch(:serialization, '')
      params[metadata.fetch(:field_name, field_name)] = [obj.to_json] if serialization == 'json'

      params
    end


    
    def self.error_status?(status)
      status_major = status / 100
      return true if status_major == 4
      return true if status_major == 5

      false
    end

    
    def self.match_content_type(content_type, pattern)
      return true if content_type == pattern || ['*', '*/*'].include?(pattern)

      pieces = content_type.split(';')
      pieces.each do |piece|
        return true if pattern == piece.strip
      end

      false
    end

    
    def self.match_status_code(status_code, status_codes)
      return true if status_codes.include? 'default'
      status_code = status_code.to_s
      status_codes.each do |code|
        return true if code == status_code
        return true if code.downcase.end_with?('xx') && status_code[0] == code[0]
      end
      false
    end

    
    def self.datetime_from_iso_format(optional)
      Kernel.lambda do |s|
        return nil if optional && s.nil?

        return DateTime.strptime(s, '%Y-%m-%dT%H:%M:%S.%NZ')
      end
    end

    
    def self.date_from_iso_format(optional)
      Kernel.lambda do |s|
        return nil if optional && s.nil?

        return Date.iso8601(s)
      end
    end

    
    def self.enum_from_string(enum_type, optional)
      Kernel.lambda do |s|
        return nil if optional && s.nil?

        return enum_type.deserialize(s)
      end
    end

    
    def self.open_enum_from_string(enum_type, optional)
      Kernel.lambda do |s|
        return nil if optional && s.nil?

        return enum_type.deserialize(s)
      end
    end

    
    def self.field_name(name)
      proc { name }
    end


    
    def self.parse_field(field, data_class)
      field_metadata = field.metadata[:metadata_string]
      return nil if field_metadata.nil?

      field_value = data_class.send(field.name)
      return nil if field_value.nil?

      field_value
    end

    
    def self.encode_form(form)
      payload = {}
      form.each do |field_name, field|
        
        if field.length == 2
          if field[0].nil?
            # Handle multiple values for the same field name (arrays)
            if payload.key?(field_name)
              # Convert to array if not already
              unless payload[field_name].is_a?(Array)
                payload[field_name] = [payload[field_name]]
              end
              payload[field_name] << field[1]
            else
              payload[field_name] = field[1]
            end
          else
            # Handle file uploads
            file_part = Faraday::Multipart::FilePart.new(
              StringIO.new(field[1]),
              mime_type_for_filename(field[0]),
              field[0]
            )
            
            # Handle multiple files for the same field name (arrays)
            if payload.key?(field_name)
              unless payload[field_name].is_a?(Array)
                payload[field_name] = [payload[field_name]]
              end
              payload[field_name] << file_part
            else
              payload[field_name] = file_part
            end
          end
        elsif field.length == 3
          param_part = Faraday::Multipart::ParamPart.new(field[1], field[2])
          
          # Handle multiple values for the same field name (arrays)
          if payload.key?(field_name)
            unless payload[field_name].is_a?(Array)
              payload[field_name] = [payload[field_name]]
            end
            payload[field_name] << param_part
          else
            payload[field_name] = param_part
          end
        end
      end
      payload
    end

    
    def self._populate_from_globals(param_name, value, param_type, gbls)
      if value.nil? && !gbls.nil?
        global_value = gbls.dig(:parameters, param_type.to_sym, param_name.to_sym)
        value = global_value if !global_value.nil?
      end
      value
    end

  end
end
